{"version":3,"sources":["webpack:///./googleCloud/api/GoogleCloudApi.js","webpack:///./googleCloud/utils/getServers.js","webpack:///./customHooks/useServer.js","webpack:///./customHooks/useQuery.js","webpack:///./routes/ViewerRouting.js"],"names":["GoogleCloudApi","accessToken","console","error","this","project","location","dataset","dicomStore","urlBase","urlStr","config","params","url","URL","data","search","URLSearchParams","fetch","fetchConfig","response","json","status","nextPageToken","pageToken","doRequest","key","subPage","hasOwnProperty","concat","isError","message","projectId","urlBaseProject","locationId","Error","method","headers","Authorization","healthcareApiEndpoint","getServers","name","wadoUriRoot","qidoRoot","wadoRoot","imageRendering","thumbnailRendering","type","active","supportsFuzzyMatching","qidoSupportsIncludeField","isValidServer","server","isEqualServer","toCompare","serverLength","Object","keys","length","toCompareLength","getActiveServer","servers","find","a","appConfig","enableGoogleCloudAdapter","pathUrl","getUrlBaseDicomWeb","GoogleCloudUtilServers","setServers","dispatch","useServerFromUrl","previousServers","activeServer","urlBasedServers","serverHasChanged","newServer","exists","some","bind","undefined","useServer","useSelector","state","usePrevious","useDispatch","useContext","AppContext","useLocation","UrlUtil","utils","urlUtil","getSeriesInstanceUIDs","seriesInstanceUIDs","routeLocation","queryFilters","queryString","getQueryFilters","querySeriesUIDs","_seriesInstanceUIDs","paramString","parseParam","ViewerRouting","routeMatch","match","studyInstanceUIDs","authToken","useQuery","get","user","getAccessToken","studyUIDs","seriesUIDs","ConnectedViewerRetrieveStudyData","propTypes","PropTypes","shape","string","isRequired","any"],"mappings":"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","file":"ViewerRouting.bundle.1efb713738d3f1503c47.js","sourcesContent":["class GoogleCloudApi {\n  setAccessToken(accessToken) {\n    if (!accessToken) console.error('Access token is empty');\n    this.accessToken = accessToken;\n  }\n\n  get fetchConfig() {\n    if (!this.accessToken) throw new Error('OIDC access_token is not set');\n    return {\n      method: 'GET',\n      headers: {\n        Authorization: 'Bearer ' + this.accessToken,\n      },\n    };\n  }\n\n  get urlBase() {\n    return this.healthcareApiEndpoint || 'https://healthcare.googleapis.com/v1beta1';\n  }\n\n  set urlBase(url) {\n    this.healthcareApiEndpoint = url;\n  }\n\n  get urlBaseProject() {\n    return this.urlBase + `/projects`;\n  }\n\n  getUrlBaseDicomWeb(project, location, dataset, dicomStore) {\n    return (\n      this.urlBase +\n      `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}/dicomWeb`\n    );\n  }\n\n  getUrlPath(project, location, dataset, dicomStore) {\n    `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}`;\n  }\n\n  async doRequest(urlStr, config = {}, params = {}) {\n    const url = new URL(urlStr);\n    let data = null;\n    url.search = new URLSearchParams(params);\n\n    try {\n      const response = await fetch(url, { ...this.fetchConfig, config });\n      try {\n        data = await response.json();\n      } catch (err) {}\n      if (response.status >= 200 && response.status < 300 && data != null) {\n        if (data.nextPageToken != null) {\n          params.pageToken = data.nextPageToken;\n          let subPage = await this.doRequest(urlStr, config, params);\n          for (let key in data) {\n            if (data.hasOwnProperty(key)) {\n              data[key] = data[key].concat(subPage.data[key]);\n            }\n          }\n        }\n        return {\n          isError: false,\n          status: response.status,\n          data,\n        };\n      } else {\n        return {\n          isError: true,\n          status: response.status,\n          message:\n            (data && data.error && data.error.message) || 'Unknown error',\n        };\n      }\n    } catch (err) {\n      if (data && data.error) {\n        return {\n          isError: true,\n          status: err.status,\n          message: err.response.data.error.message || 'Unspecified error',\n        };\n      }\n      return {\n        isError: true,\n        message: (err && err.message) || 'Oops! Something went wrong',\n      };\n    }\n  }\n\n  async loadProjects() {\n    return this.doRequest(\n      'https://cloudresourcemanager.googleapis.com/v1/projects'\n    );\n  }\n\n  async loadLocations(projectId) {\n    return this.doRequest(`${this.urlBaseProject}/${projectId}/locations`);\n  }\n\n  async loadDatasets(projectId, locationId) {\n    return this.doRequest(\n      `${this.urlBaseProject}/${projectId}/locations/${locationId}/datasets`\n    );\n  }\n\n  async loadDicomStores(dataset) {\n    return this.doRequest(`${this.urlBase}/${dataset}/dicomStores`);\n  }\n}\n\nexport default new GoogleCloudApi();\n","const getServers = (data, name) => {\n  const {\n    wadoUriRoot,\n    qidoRoot,\n    wadoRoot,\n    dataset = '',\n    dicomStore = '',\n    location = '',\n    project = '',\n  } = data;\n\n  return [\n    {\n      name: name,\n      dataset,\n      dicomStore,\n      location,\n      project,\n      imageRendering: 'wadors',\n      thumbnailRendering: 'wadors',\n      type: 'dicomWeb',\n      active: true,\n      wadoUriRoot,\n      qidoRoot,\n      wadoRoot,\n      supportsFuzzyMatching: false,\n      qidoSupportsIncludeField: false,\n    },\n  ];\n};\n\nconst isValidServer = server => {\n  return (\n    server &&\n    !!server.dataset &&\n    !!server.dicomStore &&\n    !!server.location &&\n    !!server.project\n  );\n};\n\nconst isEqualServer = (server = {}, toCompare = {}) => {\n  const serverLength = Object.keys(server).length;\n  const toCompareLength = Object.keys(toCompare).length;\n\n  if (!serverLength || !toCompareLength) {\n    return false;\n  }\n\n  return (\n    server.dataset === toCompare.dataset &&\n    server.dataset === toCompare.dataset &&\n    server.dicomStore === toCompare.dicomStore &&\n    server.location === toCompare.location &&\n    server.project === toCompare.project\n  );\n};\n\nexport { getServers, isValidServer, isEqualServer };\n","import React, { useContext } from 'react';\nimport GoogleCloudApi from '../googleCloud/api/GoogleCloudApi';\nimport usePrevious from './usePrevious';\n\nimport * as GoogleCloudUtilServers from '../googleCloud/utils/getServers';\nimport { useSelector, useDispatch } from 'react-redux';\nimport isEqual from 'lodash.isequal';\n\n// Contexts\nimport AppContext from '../context/AppContext';\n\nconst getActiveServer = servers => {\n  const isActive = a => a.active === true;\n\n  return servers && servers.servers && servers.servers.find(isActive);\n};\n\nconst getServers = (appConfig, project, location, dataset, dicomStore) => {\n  let servers = [];\n  if (appConfig.enableGoogleCloudAdapter) {\n    GoogleCloudApi.urlBase = appConfig.healthcareApiEndpoint;\n    const pathUrl = GoogleCloudApi.getUrlBaseDicomWeb(\n      project,\n      location,\n      dataset,\n      dicomStore\n    );\n    const data = {\n      project,\n      location,\n      dataset,\n      dicomStore,\n      wadoUriRoot: pathUrl,\n      qidoRoot: pathUrl,\n      wadoRoot: pathUrl,\n    };\n    servers = GoogleCloudUtilServers.getServers(data, dicomStore);\n    if (!isValidServer(servers[0], appConfig)) {\n      return;\n    }\n  }\n\n  return servers;\n};\n\nconst isValidServer = (server, appConfig) => {\n  if (appConfig.enableGoogleCloudAdapter) {\n    return GoogleCloudUtilServers.isValidServer(server);\n  }\n\n  return !!server;\n};\n\nconst setServers = (dispatch, servers) => {\n  const action = {\n    type: 'SET_SERVERS',\n    servers,\n  };\n  dispatch(action);\n};\n\nconst useServerFromUrl = (\n  servers = [],\n  previousServers,\n  activeServer,\n  urlBasedServers,\n  appConfig,\n  project,\n  location,\n  dataset,\n  dicomStore\n) => {\n  // update state from url available only when gcloud on\n  if (!appConfig.enableGoogleCloudAdapter) {\n    return false;\n  }\n\n  const serverHasChanged = previousServers !== servers && previousServers;\n\n  // do not update from url. use state instead.\n  if (serverHasChanged) {\n    return false;\n  }\n\n  // if no valid urlbased servers\n  if (!urlBasedServers || !urlBasedServers.length) {\n    return false;\n  } else if (!servers.length || !activeServer) {\n    // no current valid server\n    return true;\n  }\n\n  const newServer = urlBasedServers[0];\n\n  let exists = servers.some(\n    GoogleCloudUtilServers.isEqualServer.bind(undefined, newServer)\n  );\n\n  return !exists;\n};\n\nexport default function useServer({\n  project,\n  location,\n  dataset,\n  dicomStore,\n} = {}) {\n  // Hooks\n  const servers = useSelector(state => state && state.servers);\n  const previousServers = usePrevious(servers);\n  const dispatch = useDispatch();\n\n  const { appConfig = {} } = useContext(AppContext);\n\n  const activeServer = getActiveServer(servers);\n  const urlBasedServers =\n    getServers(appConfig, project, location, dataset, dicomStore) || [];\n  const shouldUpdateServer = useServerFromUrl(\n    servers.servers,\n    previousServers,\n    activeServer,\n    urlBasedServers,\n    appConfig,\n    project,\n    location,\n    dataset,\n    dicomStore\n  );\n\n  if (shouldUpdateServer) {\n    setServers(dispatch, urlBasedServers);\n  } else if (isValidServer(activeServer, appConfig)) {\n    return activeServer;\n  }\n}\n","import { useLocation } from 'react-router-dom';\n\n/**\n * hook that builds on useLocation to parse\n * the query string for you.\n *\n * @name useQuery\n */\nexport default function() {\n  return new URLSearchParams(useLocation().search);\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { utils, user } from '@ohif/core';\n//\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData';\nimport useServer from '../customHooks/useServer';\nimport useQuery from '../customHooks/useQuery';\nconst { urlUtil: UrlUtil } = utils;\n\n/**\n * Get array of seriesUIDs from param or from queryString\n * @param {*} seriesInstanceUIDs\n * @param {*} location\n */\nconst getSeriesInstanceUIDs = (seriesInstanceUIDs, routeLocation) => {\n  const queryFilters = UrlUtil.queryString.getQueryFilters(routeLocation);\n  const querySeriesUIDs = queryFilters && queryFilters['seriesInstanceUID'];\n  const _seriesInstanceUIDs = seriesInstanceUIDs || querySeriesUIDs;\n\n  return UrlUtil.paramString.parseParam(_seriesInstanceUIDs);\n};\n\nfunction ViewerRouting({ match: routeMatch, location: routeLocation }) {\n  const {\n    project,\n    location,\n    dataset,\n    dicomStore,\n    studyInstanceUIDs,\n    seriesInstanceUIDs,\n  } = routeMatch.params;\n\n  // Set the user's default authToken for outbound DICOMWeb requests.\n  // Is only applied if target server does not set `requestOptions` property.\n  //\n  // See: `getAuthorizationHeaders.js`\n  let query = useQuery();\n  const authToken = query.get('token');\n\n  if (authToken) {\n    user.getAccessToken = () => authToken;\n  }\n\n  const server = useServer({ project, location, dataset, dicomStore });\n  const studyUIDs = UrlUtil.paramString.parseParam(studyInstanceUIDs);\n  const seriesUIDs = getSeriesInstanceUIDs(seriesInstanceUIDs, routeLocation);\n\n  if (server && studyUIDs) {\n    return (\n      <ConnectedViewerRetrieveStudyData\n        studyInstanceUIDs={studyUIDs}\n        seriesInstanceUIDs={seriesUIDs}\n      />\n    );\n  }\n\n  return null;\n}\n\nViewerRouting.propTypes = {\n  match: PropTypes.shape({\n    params: PropTypes.shape({\n      studyInstanceUIDs: PropTypes.string.isRequired,\n      seriesInstanceUIDs: PropTypes.string,\n      dataset: PropTypes.string,\n      dicomStore: PropTypes.string,\n      location: PropTypes.string,\n      project: PropTypes.string,\n    }),\n  }),\n  location: PropTypes.any,\n};\n\nexport default ViewerRouting;\n"],"sourceRoot":""}